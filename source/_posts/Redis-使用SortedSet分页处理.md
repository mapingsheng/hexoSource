---
title: Redis-使用SortedSet分页处理
date: 2017-03-23 12:53:35
categories: Redis
tags: Redis
---
**一、需求描述**

由于app首页的数据展示需要调用6个第三方的不同数据源的rest接口，所以app首页在使用过程中会出现请求超时的问题（app端设置超时时间为5s）；所以需要对首页进行优化；

<!--more-->

>1、由于app首页的数据展示非常像微信朋友圈的数据展示，即下拉时获取最新的数据，上推时获取历史数据，而在实际的使用场景中，上推动作大于5次的情况比较少(每天在微信朋友圈把5天前的动态翻出来[上推]的情况比较少吧)；所以打算把首页的前5页数据全部放入缓存中，不管是下拉获取新数据还是上推获取分页的老数据都统一从缓存中获取，可以有效减轻服务器压力。
>
>2、设定第三方rest接口调用超时时间，比如5分钟之内的首页刷新操作，只会读取缓存数据，不会触发调用第三方的rest接口。
>
>3、首页的刷新操作触发采用异步多线程调用，而不是采用串行方式处理；比如首页刷新时，调用6个第三方的rest接口时，启动6个线程并行异步去拉取数据，并且把新数据增量更新到缓存中。


**二、业务调整**

由于app端的分页比较特殊，比如后台数据会近实时的发生变化，所以采用常规的分页算法[(totalRecord + pageSize - 1) / pageSize;]肯定是不行的。如果仍采用这种算法，当上推刷新时，就有可能加载到上一页已经看过的数据，比如用户当前正在看第2页的历史数据，如果此时后台数据源新增了一条数据，那么当用户继续上推操作查看第3页的历史数据时，就会把第2页的最后一条数据获取，并且会把该条数据作为第3页的第一条数据进行展示，这样是有问题的。

所以在数据表设计时，需要在表中增加一个自增的orderId字段参与分页，然后分页时，需要将第一页的最后一条数据的orderId回传到后台，后台拿着这个orderId进行条件判断查询并且集合上面的分页算法就可以避免上面的问题。


**二、代码开发**

>1、熟悉redis的zAdd方法

```java
	ZADD key score member [[score member] [score member] ...]

	将一个或多个 member 元素及其 score 值加入到有序集 key 当中。

	如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。

	score 值可以是整数值或双精度浮点数。
```

>2、调用zAdd方法向缓存中添加数据(用的是jedis客户端)

*这里为了看着更加清晰，没有使用for循环*
>>jedis.zadd("home_123456", 1, a);
>
>>jedis.zadd("home_123456", 2, b);
>
>>jedis.zadd("home_123456", 3, c);
>
>>jedis.zadd("home_123456", 4, d);
>
>>jedis.zadd("home_123456", 5, e);
>
>>jedis.zadd("home_123456", 6, f);
>
>>jedis.zadd("home_123456", 7, g);
>
>>jedis.zadd("home_123456", 8, h);
>
>>jedis.zadd("home_123456", 9, i);
>
>>jedis.zadd("home_123456", 10, j);

>3、熟悉zRevrangeByScore方法

```java

	ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]

	返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列。

	具有相同 score 值的成员按字典序的逆序(reverse lexicographical order )排列。

	min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下获取数据

	默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。

	举个例子：

	ZRANGEBYSCORE zset (1 5
	返回所有符合条件 1 < score <= 5 的成员，而

	ZRANGEBYSCORE zset (5 (10
	则返回所有符合条件 5 < score < 10 的成员。
```


>2、调用zRevrangeByScore方法向缓存中获取分页数据
>
>比如每页按取3条数据进行分页的话,当我们在查看第1页的前提下，上推操作，获取第2页的历史数据，需要拿到上一页数据的最后一条记录的score值【key:home_123456 score:3 value c】,所以score值为3

```java

	jedis.zrevrangeByScore("home_123456", "+inf", "("+3, 0, 3);

	这条代码的意思就是取出缓存中key为"home_123456",并且score值大于3的数据，并且从第0条开始一共取出3条(有点像 limit 0,3的作用)
	
	注：【+inf】 代表最大值不知道，所以不对区间进行最大值限制,
	    【"("+3】 等同与 【(3】，代表sore的值要小于3
```

通过上面的方法可以很好的实现在缓存中进行分页获取数据，以此可以有效提示app端的性能

